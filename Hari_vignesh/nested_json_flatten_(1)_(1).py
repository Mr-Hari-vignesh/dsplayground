# -*- coding: utf-8 -*-
"""Nested_JSON_flatten (1) (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yFZ2BH5h_EyyZKaUIRja0SlR494rh9qi

#pip installing Dataprofiler to our notebook 

(NOTE: Always pip install everything in starting of our notebook because it will restart the terminal )
"""

pip install DataProfiler[full]

"""#Mounting the data from microsoft Azure storage (bronze layer)"""

# Commented out IPython magic to ensure Python compatibility.
# %fs
ls /mnt/tf-abfss/bronze/indian_railways

"""#Importing the required library for our notebook"""

import json
import pandas as pd
from pandas.io.json import json_normalize

"""#Attaching the data and viewing the Nested JSON data"""

df = spark.read.option("multiline","true").json("/mnt/tf-abfss/bronze/indian_railways/stations.json")
df.printSchema()

"""#Orginal look of json data"""

display(df)

"""#Defining a program to flatten the Nested JSON data"""

from pyspark.sql.types import *
from pyspark.sql.functions import *

#Flatten array of structs and structs
def flatten(df):
   # compute Complex Fields (Lists and Structs) in Schema   
   complex_fields = dict([(field.name, field.dataType) ##---------It takes all the list of (fields) along with its (datatypes) in dictonary
                             for field in df.schema.fields
                             if type(field.dataType) == ArrayType or  type(field.dataType) == StructType]) ##-----it is checking whether it is                                                                                                                   (arraytype or structtype) 
   while len(complex_fields)!=0:
      col_name=list(complex_fields.keys())[0]
      print ("Processing :"+col_name+" Type : "+str(type(complex_fields[col_name])))#---to check the type of thr perticular field
    
      # if StructType then convert all sub element to columns.
      # i.e. flatten structs
      if (type(complex_fields[col_name]) == StructType): #---------
         expanded = [col(col_name+'.'+k).alias(col_name+'_'+k) for k in [ n.name for n in  complex_fields[col_name]]]
         df=df.select("*", *expanded).drop(col_name)
    
      # if ArrayType then add the Array Elements as Rows using the explode function
      # i.e. explode Arrays
      elif (type(complex_fields[col_name]) == ArrayType):    
         df=df.withColumn(col_name,explode_outer(col_name))
    
      # recompute remaining Complex Fields in Schema       
      complex_fields = dict([(field.name, field.dataType)
                             for field in df.schema.fields
                             if type(field.dataType) == ArrayType or  type(field.dataType) == StructType])
   return df

"""#After flatten the Nested Json data"""

df_flatten = flatten(df)
display(df_flatten)

df_flatten.printSchema()

"""#Converting spark dataframe to Pandas dataframe 

(why means to get a clear overview of data )(not mandatory*) i done it for my comfortness .
"""

convpandas = df_flatten.toPandas()

convpandas.describe()

convpandas.describe(include="object")

convpandas.info()

convpandas.isnull().sum()

"""#Importing the required library and profiling the data"""

import json
from dataprofiler import Data, Profiler
import dataprofiler as dp
from pyspark.sql.types import StructType, StringType, StructField, IntegerType
from pyspark.sql import SparkSession
from pyspark.sql import Row

import pandas as pd
my_dataframe = spark.read.format("json").load("dbfs:/mnt/tf-abfss/bronze/indian_railways/stations.json").toPandas()
data = dp.Profiler(my_dataframe)

report  = data.report(report_options={"output_format":"pretty"})
print(json.dumps(report, indent=4))